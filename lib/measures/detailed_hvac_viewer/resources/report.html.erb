<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>HVAC Detailed Viewer</title>
    <link
      href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.2/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script
      type="text/javascript"
      src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"
    ></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style type="text/css">
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
      }

      .grid-container {
        display: grid;
        gap: 0px; /* Reduced spacing between the grid items */
      }

      .grid-item {
        position: relative;
        width: 100px; /* Fixed size */
        height: 100px; /* Fixed size */
        background-color: #ccc;
        transition: background-color 0.3s;
      }

      .grid-icon {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%; /* Make the icon fill the cell horizontally */
        height: 100%; /* Make the icon fill the cell vertically */
        object-fit: contain; /* Maintain aspect ratio while filling the cell */
      }
      .slice text {
        font-size: 10pt;
        font-family: Arial;
      }
      .line {
        fill: none;

        stroke-width: 2px;
      }
      #plot {
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div>
      <select id="airLoopDropdown">
        <!-- Options will be dynamically populated -->
      </select>
      <select id="nodeAttributeDropdown">
        <!-- Options will be dynamically populated -->
      </select>
    </div>
    <div class="grid-container" id="grid-container">
      <!-- Generate cells for the grid -->
    </div>

    <div id="plot"></div>

    <script>
      var hvac_data = <%= hvac_data %>;

      // create image dictionary
      var imageDict = {};
      // Default icon to avoid a crash
      imageDict["Catchall"] = "missing_icon.png";
      imageDict["OS_AirConditioner_VariableRefrigerantFlow"] =
        "vrf_outdoor.png";
      imageDict["OS_AirLoopHVAC_OutdoorAirSystem"] = "OAMixer.png";
      imageDict["OS_AirLoopHVAC_UnitaryCoolOnly"] = "DXCoolingCoil.png";
      imageDict["OS_AirLoopHVAC_UnitaryHeatPump_AirToAir"] = "heat_pump3.png";
      imageDict["OS_AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed"] =
        "heat_pump3.png";
      imageDict["OS_AirLoopHVAC_UnitarySystem"] = "unitary_system.png";
      imageDict["OS_AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass"] =
        "unitary_system.png";
      imageDict["OS_AirLoopHVAC_ReturnPlenum"] = "mixer.png";
      imageDict["OS_AirLoopHVAC_SupplyPlenum"] = "splitter.png";
      imageDict["OS_AirLoopHVAC_ZoneMixer"] = "mixer.png";
      imageDict["OS_AirLoopHVAC_ZoneSplitter"] = "splitter.png";
      imageDict["OS_AirTerminal_DualDuct_VAV"] = "airterminal_dualduct_vav.png";
      imageDict["OS_AirTerminal_DualDuct_ConstantVolume"] =
        "airterminal_dualduct_constantvolume.png";
      imageDict["OS_AirTerminal_DualDuct_VAV_OutdoorAir"] =
        "airterminal_dualduct_vav_outdoorair.png";
      imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_CooledBeam"] =
        "chilled_beam.png";
      imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_Reheat"] =
        "cav_reheat.png";
      imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction"] =
        "single_ducts_constant_vol_4pipe.png";
      imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_FourPipeBeam"] =
        "airterminal_fourpipebeam.png";
      imageDict["OS_AirTerminal_SingleDuct_ParallelPIU_Reheat"] =
        "parallel_fan_terminal.png";
      imageDict["OS_AirTerminal_SingleDuct_SeriesPIU_Reheat"] =
        "series_fan_terminal.png";
      imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_NoReheat"] =
        "direct-air.png";
      imageDict["OS_AirTerminal_SingleDuct_VAV_NoReheat"] = "vav_noreheat.png";
      imageDict["OS_AirTerminal_SingleDuct_VAV_Reheat"] = "vav-reheat.png";
      imageDict["OS_AirTerminal_SingleDuct_InletSideMixer"] =
        "air_terminal_inlet_mixer.png";
      imageDict["OS_AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat"] =
        "vav_noreheat.png";
      imageDict["OS_AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat"] =
        "vav-reheat.png";
      imageDict["OS_Boiler_HotWater"] = "boiler.png";
      imageDict["OS_Boiler_Steam"] = "boiler_steam.png";
      imageDict["OS_CentralHeatPumpSystem"] = "centralheatpumpsystem.png";
      imageDict["OS_Chiller_Electric_EIR"] = "chiller_air.png";
      imageDict["OS_Chiller_Absorption_Indirect"] =
        "chiller_absorption_indirect.png";
      imageDict["OS_Chiller_Absorption"] = "chiller_absorption_direct.png";
      imageDict["OS_Coil_Cooling_DX_SingleSpeed"] =
        "dxcoolingcoil_singlespeed.png";
      imageDict["OS_Coil_Cooling_DX_TwoSpeed"] = "dxcoolingcoil_2speed.png";
      imageDict["OS_Coil_Cooling_DX_MultiSpeed"] = "dx_cooling_multispeed.png";
      imageDict["OS_Coil_Cooling_DX_VariableSpeed"] =
        "cool_coil_dx_vari_speed.png";
      imageDict["OS_Coil_Cooling_LowTemperatureRadiant_ConstantFlow"] =
        "coilcoolinglowtemprad_constflow.png";
      imageDict["OS_Coil_Cooling_LowTemperatureRadiant_VariableFlow"] =
        "coilcoolinglowtemprad_varflow.png";
      imageDict["OS_Coil_Cooling_WaterToAirHeatPump_EquationFit"] =
        "wahpDXCC.png";
      imageDict["OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit"] =
        "Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit.png";
      imageDict["OS_Coil_Cooling_Water"] = "cool_coil.png";
      imageDict["OS_Coil_Cooling_Water_Panel_Radiant"] =
        "coilcooling_water_panel_radiant.png";
      imageDict["OS_Coil_Heating_DX_SingleSpeed"] =
        "coil_ht_dx_singlespeed.png";
      imageDict["OS_Coil_Heating_DX_VariableSpeed"] = "ht_coil_dx_vari.png";
      imageDict["OS_Coil_Heating_Electric"] = "electric_furnace.png";
      imageDict["OS_Coil_Heating_Gas"] = "furnace.png";
      imageDict["OS_Coil_Heating_Gas_MultiStage"] = "furnace_multi_stage.png";
      imageDict["OS_Coil_Heating_Water"] = "heat_coil.png";
      imageDict["OS_Coil_Heating_LowTemperatureRadiant_ConstantFlow"] =
        "coilheatinglowtemprad_constflow.png";
      imageDict["OS_Coil_Heating_LowTemperatureRadiant_VariableFlow"] =
        "coilheatinglowtemprad_varflow.png";
      imageDict["OS_Coil_Heating_WaterToAirHeatPump_EquationFit"] =
        "wahpDXHC.png";
      imageDict["OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit"] =
        "Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit.png";
      imageDict["OS_CoolingTower_SingleSpeed"] = "cooling_tower.png";
      imageDict["OS_CoolingTower_TwoSpeed"] = "cooling_tower_2speed.png";
      imageDict["OS_CoolingTower_VariableSpeed"] = "cooling_tower_variable.png";
      imageDict["OS_Connector_Mixer"] = "mixer.png";
      imageDict["OS_Connector_Splitter"] = "splitter.png";
      imageDict["OS_DistrictCooling"] = "districtcooling.png";
      imageDict["OS_DistrictHeating_Water"] = "districtheating.png";
      imageDict["OS_Duct"] = "duct.png";
      imageDict["OS_EvaporativeCooler_Direct_ResearchSpecial"] =
        "directEvap.png";
      imageDict["OS_EvaporativeCooler_Indirect_ResearchSpecial"] =
        "indirectEvap.png";
      imageDict["OS_Fan_ComponentModel"] = "fan_componentmodel.png";
      imageDict["OS_Fan_ConstantVolume"] = "fan_constant.png";
      imageDict["OS_Fan_OnOff"] = "fan_on_off.png";
      imageDict["OS_Fan_SystemModel"] = "fan_systemmodel.png";
      imageDict["OS_Fan_VariableVolume"] = "fan_variable.png";
      imageDict["OS_Fan_ZoneExhaust"] = "fan_zoneexhaust.png";
      imageDict["OS_FluidCooler_SingleSpeed"] = "fluid_cooler_single.png";
      imageDict["OS_FluidCooler_TwoSpeed"] = "fluid_cooler_two.png";
      imageDict["OS_GroundHeatExchanger_Vertical"] =
        "ground_heat_exchanger_vertical.png";
      imageDict["OS_GroundHeatExchanger_HorizontalTrench"] =
        "ground_heat_exchanger_horizontal.png";
      imageDict["OS_HeaderedPumps_ConstantSpeed"] =
        "headered_pumps_constant.png";
      imageDict["OS_HeaderedPumps_VariableSpeed"] =
        "headered_pumps_variable.png";
      imageDict["OS_HeatExchanger_AirToAir_SensibleAndLatent"] =
        "heat_transfer_outdoorair.png";
      imageDict["OS_HeatExchanger_FluidToFluid"] = "fluid_hx.png";
      imageDict["OS_HeatPump_WaterToWater_EquationFit_Cooling"] =
        "heatpump_watertowater_equationfit_cooling.png";
      imageDict["OS_HeatPump_WaterToWater_EquationFit_Heating"] =
        "heatpump_watertowater_equationfit_heating.png";
      imageDict["OS_Humidifier_Steam_Electric"] = "electric_humidifier.png";
      imageDict["OS_Humidifier_Steam_Gas"] = "gas_humidifier.png";
      imageDict["OS_EvaporativeFluidCooler_SingleSpeed"] =
        "evap_fluid_cooler.png";
      imageDict["OS_EvaporativeFluidCooler_TwoSpeed"] =
        "evap_fluid_cooler_two_speed.png";
      imageDict["OS_Generator_FuelCell_ExhaustGasToWaterHeatExchanger"] =
        "generator_fuelcell_exhaustgastowaterheatexchanger.png";
      imageDict["OS_Generator_MicroTurbine_HeatRecovery"] =
        "generator_microturbine_heatrecovery.png";
      imageDict["OS_LoadProfile_Plant"] = "plant_profile.png";
      imageDict["OS_Pipe_Adiabatic"] = "pipe.png";
      imageDict["OS_Pipe_Indoor"] = "pipe_indoor.png";
      imageDict["OS_Pipe_Outdoor"] = "pipe_outdoor.png";
      imageDict["OS_PlantComponent_TemperatureSource"] =
        "plant_temp_source.png";
      imageDict["OS_PlantComponent_UserDefined"] = "user_defined.png";
      imageDict["OS_Pump_ConstantSpeed"] = "pump_constant.png";
      imageDict["OS_Pump_VariableSpeed"] = "pump_variable.png";
      imageDict["OS_Refrigeration_Condenser_AirCooled"] = "air_cooled.png";
      imageDict["OS_Refrigeration_Condenser_Cascade"] = "condenser_cascade.png";
      imageDict["OS_Refrigeration_Condenser_EvaporativeCooled"] =
        "evap_cooled.png";
      imageDict["OS_Refrigeration_Condenser_WaterCooled"] = "water_cooled.png";
      imageDict["OS_SolarCollector_FlatPlate_PhotovoltaicThermal"] =
        "solarcollector_flatplate_photovoltaicthermal.png";
      imageDict["OS_SolarCollector_FlatPlate_Water"] =
        "solarcollector_flatplate_water.png";
      imageDict["OS_SolarCollector_IntegralCollectorStorage"] =
        "solarcollector_integralstorage.png";
      imageDict["OS_SwimmingPool_Indoor"] = "swimming_pool.png";
      imageDict["OS_TemperingValve"] = "tempering_valve.png";
      imageDict["OS_ThermalZone"] = "zone.png";
      imageDict["OS_ThermalStorage_Ice_Detailed"] = "thermal_storage_ice.png";
      imageDict["OS_ThermalStorage_ChilledWater_Stratified"] =
        "thermal_storage_strat.png";
      imageDict["OS_WaterHeater_HeatPump"] = "water_heater.png";
      imageDict["OS_WaterHeater_Mixed"] = "water_heater_mixed.png";
      imageDict["OS_WaterHeater_Stratified"] = "water_heater_stratified.png";
      imageDict["OS_WaterUse_Connections"] = "water_connection.png";
      imageDict["OS_WaterUse_Equipment"] = "sink.png";
      imageDict["OS_ZoneHVAC_Baseboard_RadiantConvective_Electric"] =
        "baseboard_rad_convect_electric.png";
      imageDict["OS_ZoneHVAC_Baseboard_RadiantConvective_Water"] =
        "baseboard_rad_convect_water.png";
      imageDict["OS_ZoneHVAC_Baseboard_Convective_Electric"] =
        "baseboard_electric.png";
      imageDict["OS_ZoneHVAC_Baseboard_Convective_Water"] =
        "baseboard_water.png";
      imageDict["OS_ZoneHVAC_CoolingPanel_RadiantConvective_Water"] =
        "zonehvac_coolingpanel_radiantconvective_water.png";
      imageDict["OS_ZoneHVAC_Dehumidifier_DX"] = "dehumidifier_dx.png";
      imageDict["OS_ZoneHVAC_EnergyRecoveryVentilator"] =
        "energy_recov_vent.png";
      imageDict["OS_Coil_Heating_Water_Baseboard"] =
        "coilheatingwater_baseboard.png";
      imageDict["OS_Coil_Heating_Water_Baseboard_Radiant"] =
        "Coil_Heating_Water_Baseboard_Radiant.png";
      imageDict["OS_Coil_Cooling_CooledBeam"] = "coilcoolingchilledbeam.png";
      imageDict["OS_Coil_Cooling_FourPipeBeam"] = "coilcoolingfourpipebeam.png";
      imageDict["OS_Coil_Heating_FourPipeBeam"] = "coilheatingfourpipebeam.png";
      imageDict["OS_Coil_Heating_Desuperheater"] =
        "coilheatingdesuperheater.png";
      imageDict["OS_Coil_Cooling_DX_TwoStageWithHumidityControlMode"] =
        "dxcoolingcoil_2stage_humidity.png";
      imageDict["OS_CoilSystem_Cooling_Water_HeatExchangerAssisted"] =
        "coil_system_coolingwater_heat_exchanger.png";
      imageDict["OS_CoilSystem_Cooling_DX_HeatExchangerAssisted"] =
        "coilsystem_cooling_dx.png";
      imageDict["OS_ZoneHVAC_FourPipeFanCoil"] = "four_pipe_fan_coil.png";
      imageDict["OS_ZoneHVAC_HighTemperatureRadiant"] = "hightempradiant.png";
      imageDict["OS_ZoneHVAC_LowTemperatureRadiant_VariableFlow"] =
        "lowtempradiant_varflow.png";
      imageDict["OS_ZoneHVAC_LowTemperatureRadiant_VariableFlow"] =
        "lowtempradiant_varflow.png";
      imageDict["OS_ZoneHVAC_LowTemperatureRadiant_ConstantFlow"] =
        "lowtempradiant_constflow.png";
      imageDict["OS_ZoneHVAC_PackagedTerminalAirConditioner"] =
        "system_type_1.png";
      imageDict["OS_ZoneHVAC_PackagedTerminalHeatPump"] = "system_type_2.png";
      imageDict["OS_ZoneHVAC_TerminalUnit_VariableRefrigerantFlow"] =
        "vrf_unit.png";
      imageDict["OS_ZoneHVAC_WaterToAirHeatPump"] = "watertoairHP.png";
      imageDict["OS_ZoneHVAC_UnitHeater"] = "heat_coil-uht.png";
      imageDict["OS_ZoneHVAC_UnitVentilator"] = "unit_ventilator.png";
      // placeholder icons until unique icons available
      imageDict["OS_AvailabilityManager_Scheduled"] = "hvac-icon.png";
      imageDict["OS_AvailabilityManager_ScheduledOn"] = "hvac-icon.png";
      imageDict["OS_AvailabilityManager_ScheduledOff"] = "hvac-icon.png";
      imageDict["OS_AvailabilityManager_LowTemperatureTurnOn"] =
        "hvac-icon.png";
      imageDict["OS_AvailabilityManager_LowTemperatureTurnOff"] =
        "hvac-icon.png";
      imageDict["OS_AvailabilityManager_HighTemperatureTurnOn"] =
        "hvac-icon.png";
      imageDict["OS_AvailabilityManager_HighTemperatureTurnOff"] =
        "hvac-icon.png";
      imageDict["OS_AvailabilityManager_DifferentialThermostat"] =
        "hvac-icon.png";
      imageDict["OS_AvailabilityManager_OptimumStart"] = "hvac-icon.png";
      imageDict["OS_AvailabilityManager_NightCycle"] = "hvac-icon.png";
      imageDict["OS_AvailabilityManager_NightVentilation"] = "hvac-icon.png";
      imageDict["OS_AvailabilityManager_HybridVentilation"] = "hvac-icon.png";

      const activeNodes = {};

      function cleanObjectReferences(arr) {
          // Extract all valid object names
          const validObjectNames = new Set(arr.map(obj => obj.object_name));

          // Function to clean an array of object references
          function cleanArray(references) {
              return references.filter(ref => validObjectNames.has(ref));
          }

          // Iterate through each object in the array
          arr.forEach(obj => {
              if (Array.isArray(obj.before_objects)) {
                  obj.before_objects = cleanArray(obj.before_objects);
              }
              if (Array.isArray(obj.after_objects)) {
                  obj.after_objects = cleanArray(obj.after_objects);
              }
          });

          return arr
      }

      function splitOutdoorAirSystemObjects(objects) {
        const newObjects = [];
        var oa_object_name = "";

        objects.forEach((obj) => {
          if (obj.object_type === "OS_AirLoopHVAC_OutdoorAirSystem") {
            oa_object_name = obj.object_name;

            const firstObject = {
              object_name: obj.object_name + " Left",
              original_name: obj.object_name,
              object_type: obj.object_type,
              image_name: "OS_AirLoopHVAC_OutdoorAirSystem_Left.png",
              before_objects: obj.before_objects.filter(
                (name) => !name.includes("Outdoor Air Node")
              ),
              after_objects: [obj.object_name + " Right"].concat(
                obj.after_objects.filter((name) =>
                  name.includes("Relief Air Node")
                )
              ),
              component_side: obj.component_side,
            };

            const secondObject = {
              object_name: obj.object_name + " Right",
              original_name: obj.object_name,
              object_type: obj.object_type,
              image_name: "OS_AirLoopHVAC_OutdoorAirSystem_Right.png",
              before_objects: [obj.object_name + " Left"].concat(
                obj.before_objects.filter((name) =>
                  name.includes("Outdoor Air Node")
                )
              ),
              after_objects: obj.after_objects.filter(
                (name) => !name.includes("Relief Air Node")
              ),
              component_side: obj.component_side,
            };

            newObjects.push(firstObject, secondObject);
          } else {
            newObjects.push(obj);
          }
        });

        newObjects.forEach((obj) => {
          if (obj.after_objects) {
            obj.after_objects = obj.after_objects.map((name) => {
              if (name === oa_object_name) {
                if (obj.object_name.includes("Outdoor Air Node")) {
                  return oa_object_name + " Right";
                } else {
                  return oa_object_name + " Left";
                }
              } else {
                return name;
              }
            });
          }

          if (obj.before_objects) {
            obj.before_objects = obj.before_objects.map((name) => {
              if (name === oa_object_name) {
                if (obj.object_name.includes("Relief Air Node")) {
                  return oa_object_name + " Left";
                } else {
                  return oa_object_name + " Right";
                }
              } else {
                return name;
              }
            });
          }
        });

        return newObjects;
      }

      function assignImage(obj) {
        if (obj.object_type === "OS_Node") {
          if (
            obj.object_name.includes("Relief Air Node") ||
            obj.object_name.includes("Outdoor Air Node")
          ) {
            return "down_node.png";
          } else if (
            obj.object_name.includes("Supply Inlet Node") ||
            obj.object_name.includes(" Supply Outlet Node")
          ) {
            return "v_node.png";
          } else {
            return "h_node.png";
          }
        } else if (obj.object_type === "OS_AirLoopHVAC_OutdoorAirSystem") {
          if (obj.object_name.includes(" Left")) {
            return "OAMixer_left.png";
          } else {
            return "OAMixer_right.png";
          }
        } else {
          if (obj.object_type in imageDict) {
            return imageDict[obj.object_type];
          } else {
            return "missing_icon.png";
          }
        }
      }

      function createGrid(objects) {
        // Helper function to find the depth of each object
        function findDepth(obj, objectMap, memo) {
          if (memo[obj.object_name] !== undefined) {
            return memo[obj.object_name];
          }
          if (!obj.before_objects || obj.before_objects.length === 0) {
            return (memo[obj.object_name] = 0);
          }
          let maxDepth = 0;
          for (let before of obj.before_objects) {
            maxDepth = Math.max(
              maxDepth,
              findDepth(objectMap[before], objectMap, memo) + 1
            );
          }
          return (memo[obj.object_name] = maxDepth);
        }

        // Create a map of objects by their names for easy lookup
        const objectMap = {};
        objects.forEach((obj) => (objectMap[obj.object_name] = obj));

        // Find depth for each object
        const depthMap = {};
        objects.forEach((obj) => findDepth(obj, objectMap, depthMap));

        // Sort objects by depth
        objects.sort(
          (a, b) => depthMap[a.object_name] - depthMap[b.object_name]
        );

        // Initialize the grid
        const grid = [];
        let maxDepth = 0;
        objects.forEach((obj) => {
          maxDepth = Math.max(maxDepth, depthMap[obj.object_name]);
        });

        for (let i = 0; i <= maxDepth; i++) {
          grid[i] = [];
        }

        // get the name of the outdoor air system
        var oa_object_name = "";
        objects.forEach((obj) => {
          if (obj.object_type === "OS_AirLoopHVAC_OutdoorAirSystem") {
            oa_object_name = obj.original_name;
          }
        });

        // Assign positions on the grid
        const assignedPositions = new Set();
        objects.forEach((obj) => {
          let y = 2;
          // set relief and outdoor air nodes to the same depth as the outdoor air system
          if (obj.object_name.includes("Relief Air Node")) {
            depthMap[obj.object_name] = depthMap[oa_object_name + " Left"];
            y = 1;
          } else if (obj.object_name.includes("Outdoor Air Node")) {
            depthMap[obj.object_name] = depthMap[oa_object_name + " Right"];
            y = 1;
          }
          let depth = depthMap[obj.object_name];

          // supply inlet and outlet are 1 row below
          if (
            obj.object_name.includes("Supply Inlet Node") ||
            obj.object_name.includes("Supply Outlet Node")
          ) {
            y = 3;
          }

          // Otherwise, allocate one space
          while (assignedPositions.has(`${depth},${y}`)) {
            y++;
          }
          grid[depth][y] = obj.object_name;
          assignedPositions.add(`${depth},${y}`);
        });

        // Format the result to include x and y positions
        const result = objects.map((obj) => {
          let depth = depthMap[obj.object_name];
          let y = grid[depth].indexOf(obj.object_name);
          return {
            name: obj.object_name,
            object_type: obj.object_type,
            x: depth + 1,
            y: y,
            image_name: obj.image_name,
          };
        });

        return result;
      }

      function populateGridData(hvacData, loopName) {
        selectedLoopData = hvacData.find((hash) => hash.loop_name === loopName);
        supplyComponents = selectedLoopData["components"].filter(
          (hash) => hash.component_side === "supply"
        );
        // console.log('supplyComponents');
        // console.log(supplyComponents);

        // clean object references for no; figure out how to link to nodes that are on other loops
        supplyComponents = cleanObjectReferences(supplyComponents);

        // console.log('split object names');
        supplyComponents = splitOutdoorAirSystemObjects(supplyComponents);
        // console.log(supplyComponents);
        supplyComponents.forEach((obj) => (obj.image_name = assignImage(obj)));
        // console.log('image names');
        // console.log(supplyComponents);
        gridPositions = createGrid(supplyComponents);
        console.log("gridPositions");
        console.log(gridPositions);

        // populate gridData
        iconHash = {};
        positionNodeHash = {};
        gridPositions.forEach((obj) => {
          iconHash[`${obj.y}-${obj.x}`] = obj.image_name;
          if (obj.object_type == "OS_Node") {
            positionNodeHash[`${obj.y}-${obj.x}`] = obj.name;
          }
        });
        gridData = {};
        gridData["columns"] = Math.max(...gridPositions.map((obj) => obj.x));
        gridData["rows"] = Math.max(...gridPositions.map((obj) => obj.y));

        // add angled sections
        iconHash["2-1"] = "right_down.png";
        iconHash[`2-${gridData["columns"]}`] = "left_down.png";

        gridData["iconHash"] = iconHash;
        gridData["positionNodeHash"] = positionNodeHash;
        console.log("gridData");
        console.log(gridData);

        return gridData;
      }

      function populateLoopDropdown() {
        const dropdown = document.getElementById("airLoopDropdown");
        const attributes = new Set();
        hvac_data.forEach((loop) => attributes.add(loop.loop_name));

        attributes.forEach((attribute) => {
          const option = document.createElement("option");
          option.value = option.textContent = attribute;
          dropdown.appendChild(option);
        });
      }
      populateLoopDropdown();

      function populateNodeAttributeDropdown() {
        const dropdown = document.getElementById("nodeAttributeDropdown");
        const attributes = new Set();

        hvac_data.forEach((airLoop) => {
          airLoop.components.forEach((component) => {
            Object.keys(component).forEach((key) => {
              if (key.startsWith("system_node")) {
                attributes.add(key);
              }
            });
          });
        });

        attributes.forEach((attribute) => {
          const option = document.createElement("option");
          option.value = option.textContent = attribute;
          dropdown.appendChild(option);
        });
      }
      populateNodeAttributeDropdown();

      function getNodeValues(hvac_data, loopName, nodeName, selectedKey) {
        selectedLoopData = hvac_data.find(
          (hash) => hash.loop_name === loopName
        );
        selectedNode = selectedLoopData.components.find(
          (hash) => hash.object_name === nodeName
        );
        return selectedNode[selectedKey];
      }

      function createGridWithIcons() {
        const gridContainer = document.getElementById("grid-container");
        const gridDataScript = document.getElementById("gridData");
        const loopName = document.getElementById("airLoopDropdown").value;
        const gridData = populateGridData(hvac_data, loopName);

        const columns = gridData.columns;
        const rows = gridData.rows;
        const iconHash = gridData.iconHash;
        const positionNodeHash = gridData.positionNodeHash;

        // Set grid template columns and rows dynamically
        gridContainer.style.gridTemplateColumns = `repeat(${columns}, 100px)`;
        gridContainer.style.gridTemplateRows = `repeat(${rows}, 100px)`;

        for (let i = 0; i < columns * rows; i++) {
          const row = Math.floor(i / columns) + 1; // 1-indexed row
          const col = (i % columns) + 1; // 1-indexed column
          const position = `${row}-${col}`;
          const gridItem = document.createElement("div");
          gridItem.className = "grid-item";

          if (iconHash[position]) {
            const img = document.createElement("img");
            let alternateDirectoryTried = false;
            img.onerror = function () {
              console.log(
                "Image not found in measure directory path; trying an alternate path for tests."
              );
              if (!alternateDirectoryTried) {
                alternateDirectoryTried = true;
                img.src = `../../../resources/images/${iconHash[position]}`;
              } else {
                console.log("Image not found in the alternate path as well.");
                // Handle the case where the image is not found in both paths
              }
            };
            img.src = `../../measures/detailed_hvac_viewer/resources/images/${iconHash[position]}`;
            img.className = "grid-icon";
            gridItem.appendChild(img);

            // Add hover effect only if the cell has an icon
            gridItem.addEventListener("mouseover", () => {
              if (!activeNodes[position]) {
                gridItem.style.backgroundColor = "#888";
              }
            });
            gridItem.addEventListener("mouseout", () => {
              if (!activeNodes[position]) {
                gridItem.style.backgroundColor = "#ccc";
              }
            });

            // Add click event listener for relevant nodes
            if (positionNodeHash[position]) {
              gridItem.addEventListener("click", () => {
                const nodeName = positionNodeHash[position];
                const attributeName = document.getElementById(
                  "nodeAttributeDropdown"
                ).value;
                const NodeValues = getNodeValues(
                  hvac_data,
                  loopName,
                  nodeName,
                  attributeName
                );
                if (NodeValues) {
                  if (activeNodes[position]) {
                    delete activeNodes[position];
                    gridItem.style.backgroundColor = "#ccc";
                  } else {
                    const color = getRandomColor();
                    activeNodes[position] = { nodeName, NodeValues, color };
                    gridItem.style.backgroundColor = color;
                  }
                  plotNodeValues(activeNodes);
                }
              });
            }
          }
          gridContainer.appendChild(gridItem);
        }
      }

      // Call the function to create the grid with icons
      createGridWithIcons();

      function selectLoopEvent() {
        var dropdown = document.getElementById("airLoopDropdown");

        // Add change event listener to the dropdown
        dropdown.addEventListener("change", function () {
          // Get the selected option value
          var selectedOption = dropdown.options[dropdown.selectedIndex].value;
          console.log("Regenerating grid with option value:", selectedOption);

          // Clear the content of the div
          gridContainer = document.getElementById("grid-container");
          gridContainer.innerHTML = "";

          // Call function to regenerate the grid
          createGridWithIcons();
        });
      }

      function plotNodeValues(data) {
        let data_array = Object.values(data);

        // Using lower snake case for D3 selection elements

        /* SETUP PLOT DIMENSIONS */

        const svgWidth = 1000;
        const svgHeight = 400;

        const margin = { top: 20, right: 50, bottom: 20, left: 50 };
        const contextPadding = 50;

        const contextHeight = 50;
        const plotHeight =
          svgHeight -
          margin.top -
          margin.bottom -
          contextHeight -
          contextPadding;

        const plotWidth = svgWidth - margin.left - margin.right;

        /* FUNCTIONS AND MISC SETUP */
        function bindD3Element(parent, childtype, classname) {
          let selection;
          if (typeof parent.querySelectorAll === "function") {
            selection = d3.select(parent);
          } else {
            selection = parent;
          }
          return selection
            .selectAll(`.${classname}`)
            .data([0])
            .join(childtype)
            .attr("class", classname);
        }
        // Define the start and end dates for one year starting on January 1st

        const startDate = new Date(2023, 0, 1);
        const endDate = new Date(2024, 0, 1);

        const clipid = Math.floor(Math.random() * 1e6) + "-clip";

        const xScale = d3
          .scaleTime()
          .domain([startDate, endDate])
          .range([0, plotWidth]);

        const contextXScale = d3
          .scaleTime()
          .domain([startDate, endDate])
          .range([0, plotWidth]);

        const yMax = d3.max(data_array, (d) => d3.max(d.NodeValues));
        const yMin = d3.min(data_array, (d) => d3.min(d.NodeValues));

        const contextYScale = d3
          .scaleLinear()
          .domain([yMin, yMax])
          .range([contextHeight, 0]);

        const yScale = d3
          .scaleLinear()
          .domain([yMin, yMax])
          .range([plotHeight, 0]);

        // Create svg structure
        const plot_container = d3.select("#plot");

        const svg = bindD3Element(plot_container, "svg", "svg")
          .attr("width", svgWidth)
          .attr("height", svgHeight);

        const defs = bindD3Element(svg, "defs", "defs");

        const plot_g = bindD3Element(svg, "g", "plot-g").attr(
          "transform",
          `translate(${margin.left},${margin.top})`
        );

        const plot_lines_g = bindD3Element(plot_g, "g", "lines-g").attr(
          "clip-path",
          `url(#${clipid})`
        );

        const plot_axis_g = bindD3Element(plot_g, "g", "axis-g");

        const context_plot_g = bindD3Element(svg, "g", "context-plot-g").attr(
          "transform",
          `translate(${margin.left},${
            margin.top + plotHeight + contextPadding
          })`
        );

        const context_plot_lines_g = bindD3Element(
          context_plot_g,
          "g",
          "context-lines-g"
        ).attr("pointer-events", "none");

        const context_plot_axis_g = bindD3Element(
          context_plot_g,
          "g",
          "context-axis-g"
        );

        const x_line = bindD3Element(plot_g, "line", "x-line")
          .attr("class", "x-line")
          .attr("stroke", "black")
          .attr("stroke-dasharray", "4, 4")
          .attr("y1", 0)
          .attr("y2", plotHeight)
          .style("opacity", 0);

        const hover_g = bindD3Element(plot_g, "g", "hover-g").style(
          "opacity",
          0
        );
        const hover_rect = bindD3Element(hover_g, "rect", "hover-rect")
          .attr("width", plotWidth)
          .attr("height", plotHeight);

        const tooltip_div = bindD3Element(plot_container, "div", "tooltip-div")
          .style("opacity", 0)
          .style("background-color", "rgba(255,255,255,0.95)")
          .style("padding", "15px")
          .style("position", "absolute");

        const x_axis_g = bindD3Element(plot_axis_g, "g", "x-axis-g").attr(
          "transform",
          `translate(${0},${plotHeight})`
        );
        const y_axis_g = bindD3Element(plot_axis_g, "g", "y-axis-g");

        const context_x_axis_g = bindD3Element(
          context_plot_axis_g,
          "g",
          "context-x-axis-g"
        ).attr("transform", `translate(${0},${contextHeight})`);

        const context_y_axis_g = bindD3Element(
          context_plot_axis_g,
          "g",
          "context-y-axis-g"
        );


        const context_brush_g = bindD3Element(context_plot_g, "g", "brush");

        const clip_path = bindD3Element(defs, "clipPath", "clip-path").attr(
          "id",
          clipid
        );

        const clip_rect = bindD3Element(clip_path, "rect", "clip-rect")
          .join("rect")
          .attr("width", plotWidth)
          .attr("height", plotHeight)
          .attr("x", 0)
          .attr("y", 0);

        /* CALL AXIS FUNCTIONS */
        x_axis_g.call(
          d3
            .axisBottom(xScale)
            .ticks(d3.timeMonth.every(1))
            .tickFormat(d3.timeFormat("%b"))
        );
        y_axis_g.call(d3.axisLeft(yScale));

        context_x_axis_g.call(
          d3
            .axisBottom(xScale)
            .ticks(d3.timeMonth.every(1))
            .tickFormat(d3.timeFormat("%b"))
        );

        /* LINE FUNCTIONS */

        const createLine = function () {
          plot_lines_g
            .selectAll(".series-line")
            .data(data_array)
            .join("path")
            .attr("class", "series-line")
            .attr("d", (d, i) => {
              return d3
                .line()
                .x((d, i) => xScale(new Date(2023, 0, 1, i + 1)))
                .y((d) => yScale(d))(d.NodeValues);
            })
            .style("stroke-width", "2px")
            .style("fill", "none")
            .style("stroke", (d, i) => d.color);
        };

        const createContextLine = function () {
          context_plot_lines_g
            .selectAll(".series-line")
            .data(data_array)
            .join("path")
            .attr("class", "series-line")
            .attr("d", (d, i) => {
              return d3
                .line()
                .x((d, i) => xScale(new Date(2023, 0, 1, i + 1)))
                .y((d) => contextYScale(d))(d.NodeValues);
            })
            .style("stroke-width", "2px")
            .style("fill", "none")
            .style("stroke", (d, i) => d.color);
        };

        createLine();
        createContextLine();

        /* HANDLE HOVER */

        function mouseOut() {
          x_line.style("opacity", 0);
          tooltip_div.style("opacity", 0);
        }

        function mouseOver(e) {
          x_line.style("opacity", 1);
          tooltip_div.style("opacity", 1);
        }

        function mouseMove(e) {
          let xdate = xScale.invert(d3.pointer(e)[0]);

          // hack to get closest index from 8760 hour. probably a much better way to do this.

          let [start, end] = xScale.domain();

          let domain_fraction =
            (xdate.getTime() - start.getTime()) /
            (end.getTime() - start.getTime());

          let selected_date = new Date(
            startDate.getTime() +
              (start.getTime() - startDate.getTime()) +
              domain_fraction * (end.getTime() - start.getTime())
          );

          let annual_fraction =
            (selected_date.getTime() - startDate.getTime()) /
            (endDate.getTime() - startDate.getTime());

          let closest_idx = Math.round(annual_fraction * 8760);

          let closest_date = new Date(
            startDate.getTime() + closest_idx * 3.6e6
          );

          let pointarray = [];

          data_array.forEach((d, i) => {
            pointarray.push(d.NodeValues[closest_idx]);
          });

          x_line
            .style("opacity", 1)
            .attr("x1", xScale(xdate))
            .attr("x2", xScale(xdate));

          tooltip_div
            .style(
              "left",
              20 + event.pageX / window.innerWidth + event.pageX + "px"
            )
            .style("top", 20 + event.pageY + "px")
            .style("transition", "left 100ms, top 100ms")
            .style("z-index", 999)
            .style("opacity", 0.9).html(`
                        <div>
                            <div style="
                            padding: 5px;
                            margin-left: 5px;
                            ">
                                ${d3.timeFormat("%B %d %H:%M")(closest_date)}
                            </div>
                            ${pointarray
                              .map((d, i) => {
                                let node_name = data_array[i].nodeName;
                                let node_val = d;

                                return `
                                <div
                                style="
                                opacity: 1.0;

                                overflow: hidden;
                                white-space: nowrap';
                                ">
                                    <div class='tooltip-rect' style=
                                    "
                                    display: inline-block;
                                    width: 20px;
                                    background-color: ${data_array[i].color};
                                    height: 20px;
                                    margin-left: 10px;
                                    margin-right: 10px;
                                    transition: opacity 200ms;
                                    box-sizing: border-box;
                                    border-radius: 2px;
                                    position: relative;
                                    top: 5px
                                    "
                                    ></div>
                                    <div style="display: inline-block">${node_name}: ${node_val} </div>
                              </div>`;
                              })
                              .join("")}
                          </div>`);
        }

        hover_rect.on("mouseover", mouseOver);
        hover_rect.on("mouseout", mouseOut);
        hover_rect.on("mousemove", mouseMove);

        /* HANDLE ZOOM & BRUSH */

        const brush = d3
          .brushX()
          .extent([
            [0, 0],
            [plotWidth, contextHeight],
          ])
          .on("brush end", brushed);

        const zoomFunc = d3
          .zoom()
          .scaleExtent([1, Infinity])
          .translateExtent([
            [0, 0],
            [plotWidth, plotHeight],
          ])
          .extent([
            [0, 0],
            [plotWidth, plotHeight],
          ])
          .on("zoom", zoomed);

        let idleTimeout;
        let idleDelay = 350;

        function idled() {
          idleTimeout = null;
        }

        function brushed(event) {
          if (event.sourceEvent && event.sourceEvent.type === "zoom") return; // ignore brush-by-zoom
          var s = event.selection || contextXScale.range();

          let xdomain = s.map(contextXScale.invert, contextXScale);
          xScale.domain(xdomain);

          createLine(xdomain);
          x_axis_g.call(d3.axisBottom(xScale));
        }

        function zoomed(event) {
          if (event.sourceEvent && event.sourceEvent.type === "brush") return; // ignore zoom-by-brush
          var t = event.transform;
          let xdomain = t.rescaleX(contextXScale).domain();
          xScale.domain(xdomain);
          createLine(xdomain);
          x_axis_g.call(d3.axisBottom(xScale));
          context_plot_g
            .select(".brush")
            .call(brush.move, xScale.range().map(t.invertX, t));
        }

        context_brush_g.call(brush);

        x_axis_g.call(d3.axisBottom(xScale));

        hover_g.call(zoomFunc);
      }

      /* END D3 MULTILINE PLOT */

      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }
      // Call function to attach event listener when the DOM is fully loaded
      document.addEventListener("DOMContentLoaded", selectLoopEvent);
    </script>
  </body>
</html>
