<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8">
<title>HVAC Detailed Viewer</title>
<link href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet">
<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style type="text/css">
	body {
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		height: 100vh;
		margin: 0;
		background-color: #f0f0f0;
	}

	.grid-container {
		display: grid;
		gap: 0px;  /* Reduced spacing between the grid items */
	}

	.grid-item {
		position: relative;
		width: 100px; /* Fixed size */
		height: 100px; /* Fixed size */
		background-color: #ccc;
		transition: background-color 0.3s;
	}

	.grid-icon {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;  /* Make the icon fill the cell horizontally */
		height: 100%; /* Make the icon fill the cell vertically */
		object-fit: contain; /* Maintain aspect ratio while filling the cell */
	}
	.slice text {
        font-size: 10pt;
        font-family: Arial;
    }
	.line {
      fill: none;

      stroke-width: 2px;
    }
	#plot {
		margin-top: 20px;
	}
</style>
</head>
<body>
<div>
  <select id="airLoopDropdown">
		<!-- Options will be dynamically populated -->
  </select>
  <select id="nodeAttributeDropdown">
    <!-- Options will be dynamically populated -->
  </select>
</div>
<div class="grid-container" id="grid-container">
	<!-- Generate cells for the grid -->
</div>

<div id='plot'></div>

<script>
var hvac_data = <%= hvac_data %>;

const activeNodes = {};

function splitOutdoorAirSystemObjects(objects) {
    const newObjects = [];
    var oa_object_name = '';

    objects.forEach(obj => {
        if (obj.object_type === "OS_AirLoopHVAC_OutdoorAirSystem") {
          oa_object_name = obj.object_name

            const firstObject = {
                object_name: obj.object_name + " Left",
                original_name: obj.object_name,
                object_type: obj.object_type,
                image_name: 'OS_AirLoopHVAC_OutdoorAirSystem_Left.png',
                before_objects: obj.before_objects.filter(name => !name.includes("Outdoor Air Node")),
                after_objects: [obj.object_name + " Right"].concat(obj.after_objects.filter(name => name.includes("Relief Air Node"))),
                component_side: obj.component_side
            };

            const secondObject = {
                object_name: obj.object_name + " Right",
                original_name: obj.object_name,
                object_type: obj.object_type,
                image_name: 'OS_AirLoopHVAC_OutdoorAirSystem_Right.png',
                before_objects: [obj.object_name + " Left"].concat(obj.before_objects.filter(name => name.includes("Outdoor Air Node"))),
                after_objects: obj.after_objects.filter(name => !name.includes("Relief Air Node")),
                component_side: obj.component_side
            };

            newObjects.push(firstObject, secondObject);
        } else {
            newObjects.push(obj);
        }
    });

    newObjects.forEach(obj => {
        if (obj.after_objects) {
            obj.after_objects = obj.after_objects.map(name => {
                if (name === oa_object_name) {
                  if (obj.object_name.includes("Outdoor Air Node")) {
                        return oa_object_name + " Right"
                    } else {
                        return oa_object_name + " Left"
                    }
                } else {
                    return name
                }
            })
        };

        if (obj.before_objects) {
            obj.before_objects = obj.before_objects.map(name => {
                if (name === oa_object_name) {
                    if (obj.object_name.includes("Relief Air Node")) {
                        return oa_object_name + " Left"
                    } else {
                        return oa_object_name + " Right"
                    }
                } else {
                    return name
                }
            })
        };
    });

    return newObjects;
}

function assignImage(obj){
    if (obj.object_type === 'OS_Node') {
        if (obj.object_name.includes("Relief Air Node") || obj.object_name.includes("Outdoor Air Node")) {
            return "down_node.png"
        } else if (obj.object_name.includes("Supply Inlet Node") || obj.object_name.includes(" Supply Outlet Node")) {
            return "v_node.png"
        } else {
            return "h_node.png"
        }
    } else if (obj.object_type === 'OS_AirLoopHVAC_OutdoorAirSystem') {
        if (obj.object_name.includes(" Left")) {
            return 'OS_AirLoopHVAC_OutdoorAirSystem_Left.png'
        } else {
            return 'OS_AirLoopHVAC_OutdoorAirSystem_Right.png'
        }
    } else {
          return obj.object_type + ".png"
    }
};

function createGrid(objects) {
    // Helper function to find the depth of each object
    function findDepth(obj, objectMap, memo) {
        if (memo[obj.object_name] !== undefined) {
            return memo[obj.object_name];
        }
        if (!obj.before_objects || obj.before_objects.length === 0) {
            return memo[obj.object_name] = 0;
        }
        let maxDepth = 0;
        for (let before of obj.before_objects) {
            maxDepth = Math.max(maxDepth, findDepth(objectMap[before], objectMap, memo) + 1);
        }
        return memo[obj.object_name] = maxDepth;
    }

    // Create a map of objects by their names for easy lookup
    const objectMap = {};
    objects.forEach(obj => objectMap[obj.object_name] = obj);

    // Find depth for each object
    const depthMap = {};
    objects.forEach(obj => findDepth(obj, objectMap, depthMap));

    // Sort objects by depth
    objects.sort((a, b) => depthMap[a.object_name] - depthMap[b.object_name]);

    // Initialize the grid
    const grid = [];
    let maxDepth = 0;
    objects.forEach(obj => {
        maxDepth = Math.max(maxDepth, depthMap[obj.object_name]);
    });

    for (let i = 0; i <= maxDepth; i++) {
        grid[i] = [];
    }

    // get the name of the outdoor air system
    var oa_object_name = ''
    objects.forEach(obj => {
      if (obj.object_type === "OS_AirLoopHVAC_OutdoorAirSystem") {
        oa_object_name = obj.original_name
      };
    });

    // Assign positions on the grid
    const assignedPositions = new Set();
    objects.forEach(obj => {
        let y = 2;
        // set relief and outdoor air nodes to the same depth as the outdoor air system
        if (obj.object_name.includes('Relief Air Node')) {
            depthMap[obj.object_name] = depthMap[oa_object_name + " Left"]
            y = 1;
        } else if (obj.object_name.includes('Outdoor Air Node')){
            depthMap[obj.object_name] = depthMap[oa_object_name + " Right"]
            y = 1;
        }
        let depth = depthMap[obj.object_name];

        // supply inlet and outlet are 1 row below
        if (obj.object_name.includes('Supply Inlet Node') || obj.object_name.includes('Supply Outlet Node')) {
          y = 3;
        }

        // Otherwise, allocate one space
        while (assignedPositions.has(`${depth},${y}`)) {
            y++;
        }
        grid[depth][y] = obj.object_name;
        assignedPositions.add(`${depth},${y}`);
    });

    // Format the result to include x and y positions
    const result = objects.map(obj => {
        let depth = depthMap[obj.object_name];
        let y = grid[depth].indexOf(obj.object_name);
        return {
            name: obj.object_name,
            object_type: obj.object_type,
            x: depth + 1,
            y: y,
            image_name: obj.image_name
        };
    });

    return result;
}

function populateGridData(hvacData, loopName) {
    selectedLoopData = hvacData.find(hash => hash.loop_name === loopName)
    supplyComponents = selectedLoopData["components"].filter(hash => hash.component_side === 'supply')
    // console.log('supplyComponents');
    // console.log(supplyComponents);
    // console.log('split object names');
    supplyComponents = splitOutdoorAirSystemObjects(supplyComponents);
    // console.log(supplyComponents);
    supplyComponents.forEach(obj => obj.image_name = assignImage(obj));
    // console.log('image names');
    // console.log(supplyComponents);
    gridPositions = createGrid(supplyComponents);
    console.log('gridPositions');
    console.log(gridPositions);

    // populate gridData
    iconHash = {}
    positionNodeHash = {}
    gridPositions.forEach(obj => {
        iconHash[`${obj.y}-${obj.x}`] = obj.image_name;
        if (obj.object_type == 'OS_Node') {
          positionNodeHash[`${obj.y}-${obj.x}`] = obj.name
        }
    });
    gridData = {}
    gridData["columns"] = Math.max(...gridPositions.map(obj => obj.x));
    gridData["rows"] = Math.max(...gridPositions.map(obj => obj.y));

    // add angled sections
    iconHash['2-1'] = "right_down.png"
    iconHash[`2-${gridData["columns"]}`] = 'left_down.png'

    gridData["iconHash"] = iconHash
    gridData["positionNodeHash"] = positionNodeHash
    console.log('gridData');
    console.log(gridData);

    return gridData
};

function populateLoopDropdown() {
  const dropdown = document.getElementById('airLoopDropdown');
  const attributes = new Set();
  hvac_data.forEach( loop => attributes.add(loop.loop_name) );

attributes.forEach(attribute => {
    const option = document.createElement('option');
    option.value = option.textContent = attribute;
    dropdown.appendChild(option);
  });
}
populateLoopDropdown();

function populateNodeAttributeDropdown() {
  const dropdown = document.getElementById('nodeAttributeDropdown');
  const attributes = new Set();

  hvac_data.forEach(airLoop => {
    airLoop.components.forEach(component => {
      Object.keys(component).forEach(key => {
        if (key.startsWith('system_node')) {
          attributes.add(key);
        }
      });
    });
  });

  attributes.forEach(attribute => {
    const option = document.createElement('option');
    option.value = option.textContent = attribute;
    dropdown.appendChild(option);
  });
}
populateNodeAttributeDropdown();

function getNodeValues(hvac_data, loopName, nodeName, selectedKey) {
  selectedLoopData = hvac_data.find(hash => hash.loop_name === loopName);
  selectedNode = selectedLoopData.components.find(hash => hash.object_name === nodeName);
  return selectedNode[selectedKey];
}

function createGridWithIcons() {
	const gridContainer = document.getElementById('grid-container');
	const gridDataScript = document.getElementById('gridData');
	const loopName = document.getElementById('airLoopDropdown').value;
	const gridData = populateGridData(hvac_data, loopName);

	const columns = gridData.columns;
	const rows = gridData.rows;
	const iconHash = gridData.iconHash;
	const positionNodeHash = gridData.positionNodeHash;

	// Set grid template columns and rows dynamically
	gridContainer.style.gridTemplateColumns = `repeat(${columns}, 100px)`;
	gridContainer.style.gridTemplateRows = `repeat(${rows}, 100px)`;

	for (let i = 0; i < columns * rows; i++) {
		const row = Math.floor(i / columns) + 1; // 1-indexed row
		const col = (i % columns) + 1; // 1-indexed column
		const position = `${row}-${col}`;
		const gridItem = document.createElement('div');
		gridItem.className = 'grid-item';

		if (iconHash[position]) {
			const img = document.createElement('img');
			let alternateDirectoryTried = false;
			img.onerror = function () {
				console.log("Image not found in measure directory path; trying an alternate path for tests.");
				if (!alternateDirectoryTried) {
					alternateDirectoryTried = true;
					img.src = `../../../resources/images/${iconHash[position]}`;
				} else {
					console.log("Image not found in the alternate path as well.");
					// Handle the case where the image is not found in both paths
				}
			}
			img.src = `../../measures/detailed_hvac_viewer/resources/images/${iconHash[position]}`;
			img.className = 'grid-icon';
			gridItem.appendChild(img);

			// Add hover effect only if the cell has an icon
			gridItem.addEventListener('mouseover', () => {
				if (!activeNodes[position]) {
					gridItem.style.backgroundColor = '#888';
				}
			});
			gridItem.addEventListener('mouseout', () => {
				if (!activeNodes[position]) {
					gridItem.style.backgroundColor = '#ccc';
				}
			});

			// Add click event listener for relevant nodes
			if (positionNodeHash[position]) {
				gridItem.addEventListener('click', () => {
					const nodeName = positionNodeHash[position];
					const attributeName = document.getElementById('nodeAttributeDropdown').value;
					const NodeValues = getNodeValues(hvac_data, loopName, nodeName, attributeName);
					if (NodeValues) {
						if (activeNodes[position]) {
							delete activeNodes[position];
							gridItem.style.backgroundColor = '#ccc';
						} else {
							const color = getRandomColor();
							activeNodes[position] = { nodeName, NodeValues, color };
							gridItem.style.backgroundColor = color;
						}
						plotNodeValues();
					}
				});
			}
		}
		gridContainer.appendChild(gridItem);
	}
}

// Call the function to create the grid with icons
createGridWithIcons();

function selectLoopEvent() {
  var dropdown = document.getElementById('loopDropdown');

  // Add change event listener to the dropdown
  dropdown.addEventListener('change', function() {
      // Get the selected option value
      var selectedOption = dropdown.options[dropdown.selectedIndex].value;
      console.log("Regenerating grid with option value:", selectedOption);

      // Clear the content of the div
      gridContainer = document.getElementById('grid-container');
      gridContainer.innerHTML = "";

      // Call function to regenerate the grid
      createGridWithIcons();
  });
}

// Call function to attach event listener when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', selectLoopEvent);

function plotNodeValues(data) {
    d3.select("#plot").html(""); // Clear any existing plot

    const margin = {top: 20, right: 20, bottom: 30, left: 50};
    const width = 1000 - margin.left - margin.right;
    const height = 300 - margin.top - margin.bottom;

    // Define the start and end dates for one year starting on January 1st
    const startDate = new Date(2023, 0, 1);
    const endDate = new Date(2024, 0, 1);

	// Create a time scale for the x-axis
    const x = d3.scaleTime()
				.domain([startDate, endDate])
				.range([0, width]);

    const yMax = d3.max(Object.values(activeNodes), d => d3.max(d.NodeValues));
    const yMin = d3.min(Object.values(activeNodes), d => d3.min(d.NodeValues));

    const y = d3.scaleLinear()
                .domain([yMin, yMax])
                .range([height, 0]);

    // Define the line function
    const line = d3.line()
        .x((d, i) => x(new Date(2023, 0, 1, i + 1)))
        .y(d => y(d));

    // Create the SVG container
    const svg = d3.select("#plot").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Add the x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(d3.timeMonth.every(1)).tickFormat(d3.timeFormat("%b")));


    svg.append("g")
		.call(d3.axisLeft(y));

	Object.values(activeNodes).forEach(node => {
		svg.append("path")
			.data([node.NodeValues])
			.attr("class", "line")
			.attr("d", line)
			.attr("stroke", node.color);
	});
}

function getRandomColor() {
	const letters = '0123456789ABCDEF';
	let color = '#';
	for (let i = 0; i < 6; i++) {
		color += letters[Math.floor(Math.random() * 16)];
	}
	return color;
}
</script>

</body>
</html>
