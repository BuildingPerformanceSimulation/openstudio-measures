<!DOCTYPE html>

<html>
<head>
<meta charset="utf-8">
<title>HVAC Detailed Viewer</title>
<link href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet">
<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style type="text/css">
	body {
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
		height: 100vh;
		margin: 0;
		background-color: #f0f0f0;
	}

	.grid-container {
		display: grid;
		gap: 0px;  /* Reduced spacing between the grid items */
	}

	.grid-item {
		position: relative;
		width: 100px; /* Fixed size */
		height: 100px; /* Fixed size */
		background-color: #ccc;
		transition: background-color 0.3s;
	}

	.grid-icon {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;  /* Make the icon fill the cell horizontally */
		height: 100%; /* Make the icon fill the cell vertically */
		object-fit: contain; /* Maintain aspect ratio while filling the cell */
	}
	.slice text {
        font-size: 10pt;
        font-family: Arial;
    }
	.line {
      fill: none;

      stroke-width: 2px;
    }
	#plot {
		margin-top: 20px;
	}
</style>
</head>
<body>
<div>
  <select id="airLoopDropdown">
		<!-- Options will be dynamically populated -->
  </select>
  <select id="nodeAttributeDropdown">
    <!-- Options will be dynamically populated -->
  </select>
</div>
<div class="grid-container" id="grid-container">
	<!-- Generate cells for the grid -->
</div>

<div id='plot'></div>

<script>
var hvac_data = <%= hvac_data %>;

// create image dictionary
var imageDict = {}
// Default icon to avoid a crash
imageDict["Catchall"] = "missing_icon.png";
imageDict["OS_AirConditioner_VariableRefrigerantFlow"] = "vrf_outdoor.png";
imageDict["OS_AirLoopHVAC_OutdoorAirSystem"] = "OAMixer.png";
imageDict["OS_AirLoopHVAC_UnitaryCoolOnly"] = "DXCoolingCoil.png";
imageDict["OS_AirLoopHVAC_UnitaryHeatPump_AirToAir"] = "heat_pump3.png";
imageDict["OS_AirLoopHVAC_UnitaryHeatPump_AirToAir_MultiSpeed"] = "heat_pump3.png";
imageDict["OS_AirLoopHVAC_UnitarySystem"] = "unitary_system.png";
imageDict["OS_AirLoopHVAC_UnitaryHeatCool_VAVChangeoverBypass"] = "unitary_system.png";
imageDict["OS_AirLoopHVAC_ReturnPlenum"] = "mixer.png";
imageDict["OS_AirLoopHVAC_SupplyPlenum"] = "splitter.png";
imageDict["OS_AirLoopHVAC_ZoneMixer"] = "mixer.png";
imageDict["OS_AirLoopHVAC_ZoneSplitter"] = "splitter.png";
imageDict["OS_AirTerminal_DualDuct_VAV"] = "airterminal_dualduct_vav.png";
imageDict["OS_AirTerminal_DualDuct_ConstantVolume"] = "airterminal_dualduct_constantvolume.png";
imageDict["OS_AirTerminal_DualDuct_VAV_OutdoorAir"] = "airterminal_dualduct_vav_outdoorair.png";
imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_CooledBeam"] = "chilled_beam.png";
imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_Reheat"] = "cav_reheat.png";
imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_FourPipeInduction"] = "single_ducts_constant_vol_4pipe.png";
imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_FourPipeBeam"] = "airterminal_fourpipebeam.png";
imageDict["OS_AirTerminal_SingleDuct_ParallelPIU_Reheat"] = "parallel_fan_terminal.png";
imageDict["OS_AirTerminal_SingleDuct_SeriesPIU_Reheat"] = "series_fan_terminal.png";
imageDict["OS_AirTerminal_SingleDuct_ConstantVolume_NoReheat"] = "direct-air.png";
imageDict["OS_AirTerminal_SingleDuct_VAV_NoReheat"] = "vav_noreheat.png";
imageDict["OS_AirTerminal_SingleDuct_VAV_Reheat"] = "vav-reheat.png";
imageDict["OS_AirTerminal_SingleDuct_InletSideMixer"] = "air_terminal_inlet_mixer.png";
imageDict["OS_AirTerminal_SingleDuct_VAV_HeatAndCool_NoReheat"] = "vav_noreheat.png";
imageDict["OS_AirTerminal_SingleDuct_VAV_HeatAndCool_Reheat"] = "vav-reheat.png";
imageDict["OS_Boiler_HotWater"] = "boiler.png";
imageDict["OS_Boiler_Steam"] = "boiler_steam.png";
imageDict["OS_CentralHeatPumpSystem"] = "centralheatpumpsystem.png";
imageDict["OS_Chiller_Electric_EIR"] = "chiller_air.png";
imageDict["OS_Chiller_Absorption_Indirect"] = "chiller_absorption_indirect.png";
imageDict["OS_Chiller_Absorption"] = "chiller_absorption_direct.png";
imageDict["OS_Coil_Cooling_DX_SingleSpeed"] = "dxcoolingcoil_singlespeed.png";
imageDict["OS_Coil_Cooling_DX_TwoSpeed"] = "dxcoolingcoil_2speed.png";
imageDict["OS_Coil_Cooling_DX_MultiSpeed"] = "dx_cooling_multispeed.png";
imageDict["OS_Coil_Cooling_DX_VariableSpeed"] = "cool_coil_dx_vari_speed.png";
imageDict["OS_Coil_Cooling_LowTemperatureRadiant_ConstantFlow"] = "coilcoolinglowtemprad_constflow.png";
imageDict["OS_Coil_Cooling_LowTemperatureRadiant_VariableFlow"] = "coilcoolinglowtemprad_varflow.png";
imageDict["OS_Coil_Cooling_WaterToAirHeatPump_EquationFit"] = "wahpDXCC.png";
imageDict["OS_Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit"] = "Coil_Cooling_WaterToAirHeatPump_VariableSpeedEquationFit.png";
imageDict["OS_Coil_Cooling_Water"] = "cool_coil.png";
imageDict["OS_Coil_Cooling_Water_Panel_Radiant"] = "coilcooling_water_panel_radiant.png";
imageDict["OS_Coil_Heating_DX_SingleSpeed"] = "coil_ht_dx_singlespeed.png";
imageDict["OS_Coil_Heating_DX_VariableSpeed"] = "ht_coil_dx_vari.png";
imageDict["OS_Coil_Heating_Electric"] = "electric_furnace.png";
imageDict["OS_Coil_Heating_Gas"] = "furnace.png";
imageDict["OS_Coil_Heating_Gas_MultiStage"] = "furnace_multi_stage.png";
imageDict["OS_Coil_Heating_Water"] = "heat_coil.png";
imageDict["OS_Coil_Heating_LowTemperatureRadiant_ConstantFlow"] = "coilheatinglowtemprad_constflow.png";
imageDict["OS_Coil_Heating_LowTemperatureRadiant_VariableFlow"] = "coilheatinglowtemprad_varflow.png";
imageDict["OS_Coil_Heating_WaterToAirHeatPump_EquationFit"] = "wahpDXHC.png";
imageDict["OS_Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit"] = "Coil_Heating_WaterToAirHeatPump_VariableSpeedEquationFit.png";
imageDict["OS_CoolingTower_SingleSpeed"] = "cooling_tower.png";
imageDict["OS_CoolingTower_TwoSpeed"] = "cooling_tower_2speed.png";
imageDict["OS_CoolingTower_VariableSpeed"] = "cooling_tower_variable.png";
imageDict["OS_Connector_Mixer"] = "mixer.png";
imageDict["OS_Connector_Splitter"] = "splitter.png";
imageDict["OS_DistrictCooling"] = "districtcooling.png";
imageDict["OS_DistrictHeating_Water"] = "districtheating.png";
imageDict["OS_Duct"] = "duct.png";
imageDict["OS_EvaporativeCooler_Direct_ResearchSpecial"] = "directEvap.png";
imageDict["OS_EvaporativeCooler_Indirect_ResearchSpecial"] = "indirectEvap.png";
imageDict["OS_Fan_ComponentModel"] = "fan_componentmodel.png";
imageDict["OS_Fan_ConstantVolume"] = "fan_constant.png";
imageDict["OS_Fan_OnOff"] = "fan_on_off.png";
imageDict["OS_Fan_SystemModel"] = "fan_systemmodel.png";
imageDict["OS_Fan_VariableVolume"] = "fan_variable.png";
imageDict["OS_Fan_ZoneExhaust"] = "fan_zoneexhaust.png";
imageDict["OS_FluidCooler_SingleSpeed"] = "fluid_cooler_single.png";
imageDict["OS_FluidCooler_TwoSpeed"] = "fluid_cooler_two.png";
imageDict["OS_GroundHeatExchanger_Vertical"] = "ground_heat_exchanger_vertical.png";
imageDict["OS_GroundHeatExchanger_HorizontalTrench"] = "ground_heat_exchanger_horizontal.png";
imageDict["OS_HeaderedPumps_ConstantSpeed"] = "headered_pumps_constant.png";
imageDict["OS_HeaderedPumps_VariableSpeed"] = "headered_pumps_variable.png";
imageDict["OS_HeatExchanger_AirToAir_SensibleAndLatent"] = "heat_transfer_outdoorair.png";
imageDict["OS_HeatExchanger_FluidToFluid"] = "fluid_hx.png";
imageDict["OS_HeatPump_WaterToWater_EquationFit_Cooling"] = "heatpump_watertowater_equationfit_cooling.png";
imageDict["OS_HeatPump_WaterToWater_EquationFit_Heating"] = "heatpump_watertowater_equationfit_heating.png";
imageDict["OS_Humidifier_Steam_Electric"] = "electric_humidifier.png";
imageDict["OS_Humidifier_Steam_Gas"] = "gas_humidifier.png";
imageDict["OS_EvaporativeFluidCooler_SingleSpeed"] = "evap_fluid_cooler.png";
imageDict["OS_EvaporativeFluidCooler_TwoSpeed"] = "evap_fluid_cooler_two_speed.png";
imageDict["OS_Generator_FuelCell_ExhaustGasToWaterHeatExchanger"] = "generator_fuelcell_exhaustgastowaterheatexchanger.png";
imageDict["OS_Generator_MicroTurbine_HeatRecovery"] = "generator_microturbine_heatrecovery.png";
imageDict["OS_LoadProfile_Plant"] = "plant_profile.png";
imageDict["OS_Pipe_Adiabatic"] = "pipe.png";
imageDict["OS_Pipe_Indoor"] = "pipe_indoor.png";
imageDict["OS_Pipe_Outdoor"] = "pipe_outdoor.png";
imageDict["OS_PlantComponent_TemperatureSource"] = "plant_temp_source.png";
imageDict["OS_PlantComponent_UserDefined"] = "user_defined.png";
imageDict["OS_Pump_ConstantSpeed"] = "pump_constant.png";
imageDict["OS_Pump_VariableSpeed"] = "pump_variable.png";
imageDict["OS_Refrigeration_Condenser_AirCooled"] = "air_cooled.png";
imageDict["OS_Refrigeration_Condenser_Cascade"] = "condenser_cascade.png";
imageDict["OS_Refrigeration_Condenser_EvaporativeCooled"] = "evap_cooled.png";
imageDict["OS_Refrigeration_Condenser_WaterCooled"] = "water_cooled.png";
imageDict["OS_SolarCollector_FlatPlate_PhotovoltaicThermal"] = "solarcollector_flatplate_photovoltaicthermal.png";
imageDict["OS_SolarCollector_FlatPlate_Water"] = "solarcollector_flatplate_water.png";
imageDict["OS_SolarCollector_IntegralCollectorStorage"] = "solarcollector_integralstorage.png";
imageDict["OS_SwimmingPool_Indoor"] = "swimming_pool.png";
imageDict["OS_TemperingValve"] = "tempering_valve.png";
imageDict["OS_ThermalZone"] = "zone.png";
imageDict["OS_ThermalStorage_Ice_Detailed"] = "thermal_storage_ice.png";
imageDict["OS_ThermalStorage_ChilledWater_Stratified"] = "thermal_storage_strat.png";
imageDict["OS_WaterHeater_HeatPump"] = "water_heater.png";
imageDict["OS_WaterHeater_Mixed"] = "water_heater_mixed.png";
imageDict["OS_WaterHeater_Stratified"] = "water_heater_stratified.png";
imageDict["OS_WaterUse_Connections"] = "water_connection.png";
imageDict["OS_WaterUse_Equipment"] = "sink.png";
imageDict["OS_ZoneHVAC_Baseboard_RadiantConvective_Electric"] = "baseboard_rad_convect_electric.png";
imageDict["OS_ZoneHVAC_Baseboard_RadiantConvective_Water"] = "baseboard_rad_convect_water.png";
imageDict["OS_ZoneHVAC_Baseboard_Convective_Electric"] = "baseboard_electric.png";
imageDict["OS_ZoneHVAC_Baseboard_Convective_Water"] = "baseboard_water.png";
imageDict["OS_ZoneHVAC_CoolingPanel_RadiantConvective_Water"] = "zonehvac_coolingpanel_radiantconvective_water.png";
imageDict["OS_ZoneHVAC_Dehumidifier_DX"] = "dehumidifier_dx.png";
imageDict["OS_ZoneHVAC_EnergyRecoveryVentilator"] = "energy_recov_vent.png";
imageDict["OS_Coil_Heating_Water_Baseboard"] = "coilheatingwater_baseboard.png";
imageDict["OS_Coil_Heating_Water_Baseboard_Radiant"] = "Coil_Heating_Water_Baseboard_Radiant.png";
imageDict["OS_Coil_Cooling_CooledBeam"] = "coilcoolingchilledbeam.png";
imageDict["OS_Coil_Cooling_FourPipeBeam"] = "coilcoolingfourpipebeam.png";
imageDict["OS_Coil_Heating_FourPipeBeam"] = "coilheatingfourpipebeam.png";
imageDict["OS_Coil_Heating_Desuperheater"] = "coilheatingdesuperheater.png";
imageDict["OS_Coil_Cooling_DX_TwoStageWithHumidityControlMode"] = "dxcoolingcoil_2stage_humidity.png";
imageDict["OS_CoilSystem_Cooling_Water_HeatExchangerAssisted"] = "coil_system_coolingwater_heat_exchanger.png";
imageDict["OS_CoilSystem_Cooling_DX_HeatExchangerAssisted"] = "coilsystem_cooling_dx.png";
imageDict["OS_ZoneHVAC_FourPipeFanCoil"] = "four_pipe_fan_coil.png";
imageDict["OS_ZoneHVAC_HighTemperatureRadiant"] = "hightempradiant.png";
imageDict["OS_ZoneHVAC_LowTemperatureRadiant_VariableFlow"] = "lowtempradiant_varflow.png";
imageDict["OS_ZoneHVAC_LowTemperatureRadiant_VariableFlow"] = "lowtempradiant_varflow.png";
imageDict["OS_ZoneHVAC_LowTemperatureRadiant_ConstantFlow"] = "lowtempradiant_constflow.png";
imageDict["OS_ZoneHVAC_PackagedTerminalAirConditioner"] = "system_type_1.png";
imageDict["OS_ZoneHVAC_PackagedTerminalHeatPump"] = "system_type_2.png";
imageDict["OS_ZoneHVAC_TerminalUnit_VariableRefrigerantFlow"] = "vrf_unit.png";
imageDict["OS_ZoneHVAC_WaterToAirHeatPump"] = "watertoairHP.png";
imageDict["OS_ZoneHVAC_UnitHeater"] = "heat_coil-uht.png";
imageDict["OS_ZoneHVAC_UnitVentilator"] = "unit_ventilator.png";
// placeholder icons until unique icons available
imageDict["OS_AvailabilityManager_Scheduled"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_ScheduledOn"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_ScheduledOff"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_LowTemperatureTurnOn"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_LowTemperatureTurnOff"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_HighTemperatureTurnOn"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_HighTemperatureTurnOff"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_DifferentialThermostat"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_OptimumStart"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_NightCycle"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_NightVentilation"] = "hvac-icon.png";
imageDict["OS_AvailabilityManager_HybridVentilation"] = "hvac-icon.png";

const activeNodes = {};

function splitOutdoorAirSystemObjects(objects) {
    const newObjects = [];
    var oa_object_name = '';

    objects.forEach(obj => {
        if (obj.object_type === "OS_AirLoopHVAC_OutdoorAirSystem") {
          oa_object_name = obj.object_name

            const firstObject = {
                object_name: obj.object_name + " Left",
                original_name: obj.object_name,
                object_type: obj.object_type,
                image_name: 'OS_AirLoopHVAC_OutdoorAirSystem_Left.png',
                before_objects: obj.before_objects.filter(name => !name.includes("Outdoor Air Node")),
                after_objects: [obj.object_name + " Right"].concat(obj.after_objects.filter(name => name.includes("Relief Air Node"))),
                component_side: obj.component_side
            };

            const secondObject = {
                object_name: obj.object_name + " Right",
                original_name: obj.object_name,
                object_type: obj.object_type,
                image_name: 'OS_AirLoopHVAC_OutdoorAirSystem_Right.png',
                before_objects: [obj.object_name + " Left"].concat(obj.before_objects.filter(name => name.includes("Outdoor Air Node"))),
                after_objects: obj.after_objects.filter(name => !name.includes("Relief Air Node")),
                component_side: obj.component_side
            };

            newObjects.push(firstObject, secondObject);
        } else {
            newObjects.push(obj);
        }
    });

    newObjects.forEach(obj => {
        if (obj.after_objects) {
            obj.after_objects = obj.after_objects.map(name => {
                if (name === oa_object_name) {
                  if (obj.object_name.includes("Outdoor Air Node")) {
                        return oa_object_name + " Right"
                    } else {
                        return oa_object_name + " Left"
                    }
                } else {
                    return name
                }
            })
        };

        if (obj.before_objects) {
            obj.before_objects = obj.before_objects.map(name => {
                if (name === oa_object_name) {
                    if (obj.object_name.includes("Relief Air Node")) {
                        return oa_object_name + " Left"
                    } else {
                        return oa_object_name + " Right"
                    }
                } else {
                    return name
                }
            })
        };
    });

    return newObjects;
}

function assignImage(obj){
    if (obj.object_type === 'OS_Node') {
        if (obj.object_name.includes("Relief Air Node") || obj.object_name.includes("Outdoor Air Node")) {
            return "down_node.png"
        } else if (obj.object_name.includes("Supply Inlet Node") || obj.object_name.includes(" Supply Outlet Node")) {
            return "v_node.png"
        } else {
            return "h_node.png"
        }
    } else if (obj.object_type === 'OS_AirLoopHVAC_OutdoorAirSystem') {
        if (obj.object_name.includes(" Left")) {
            return 'OAMixer_left.png'
        } else {
            return 'OAMixer_right.png'
        }
    } else {
            if (obj.object_type in imageDict) {
                return imageDict[obj.object_type]
            } else {
                return "missing_icon.png"
            }
    }
};

function createGrid(objects) {
    // Helper function to find the depth of each object
    function findDepth(obj, objectMap, memo) {
        if (memo[obj.object_name] !== undefined) {
            return memo[obj.object_name];
        }
        if (!obj.before_objects || obj.before_objects.length === 0) {
            return memo[obj.object_name] = 0;
        }
        let maxDepth = 0;
        for (let before of obj.before_objects) {
            maxDepth = Math.max(maxDepth, findDepth(objectMap[before], objectMap, memo) + 1);
        }
        return memo[obj.object_name] = maxDepth;
    }

    // Create a map of objects by their names for easy lookup
    const objectMap = {};
    objects.forEach(obj => objectMap[obj.object_name] = obj);

    // Find depth for each object
    const depthMap = {};
    objects.forEach(obj => findDepth(obj, objectMap, depthMap));

    // Sort objects by depth
    objects.sort((a, b) => depthMap[a.object_name] - depthMap[b.object_name]);

    // Initialize the grid
    const grid = [];
    let maxDepth = 0;
    objects.forEach(obj => {
        maxDepth = Math.max(maxDepth, depthMap[obj.object_name]);
    });

    for (let i = 0; i <= maxDepth; i++) {
        grid[i] = [];
    }

    // get the name of the outdoor air system
    var oa_object_name = ''
    objects.forEach(obj => {
      if (obj.object_type === "OS_AirLoopHVAC_OutdoorAirSystem") {
        oa_object_name = obj.original_name
      };
    });

    // Assign positions on the grid
    const assignedPositions = new Set();
    objects.forEach(obj => {
        let y = 2;
        // set relief and outdoor air nodes to the same depth as the outdoor air system
        if (obj.object_name.includes('Relief Air Node')) {
            depthMap[obj.object_name] = depthMap[oa_object_name + " Left"]
            y = 1;
        } else if (obj.object_name.includes('Outdoor Air Node')){
            depthMap[obj.object_name] = depthMap[oa_object_name + " Right"]
            y = 1;
        }
        let depth = depthMap[obj.object_name];

        // supply inlet and outlet are 1 row below
        if (obj.object_name.includes('Supply Inlet Node') || obj.object_name.includes('Supply Outlet Node')) {
          y = 3;
        }

        // Otherwise, allocate one space
        while (assignedPositions.has(`${depth},${y}`)) {
            y++;
        }
        grid[depth][y] = obj.object_name;
        assignedPositions.add(`${depth},${y}`);
    });

    // Format the result to include x and y positions
    const result = objects.map(obj => {
        let depth = depthMap[obj.object_name];
        let y = grid[depth].indexOf(obj.object_name);
        return {
            name: obj.object_name,
            object_type: obj.object_type,
            x: depth + 1,
            y: y,
            image_name: obj.image_name
        };
    });

    return result;
}

function populateGridData(hvacData, loopName) {
    selectedLoopData = hvacData.find(hash => hash.loop_name === loopName)
    supplyComponents = selectedLoopData["components"].filter(hash => hash.component_side === 'supply')
    // console.log('supplyComponents');
    // console.log(supplyComponents);
    // console.log('split object names');
    supplyComponents = splitOutdoorAirSystemObjects(supplyComponents);
    // console.log(supplyComponents);
    supplyComponents.forEach(obj => obj.image_name = assignImage(obj));
    // console.log('image names');
    // console.log(supplyComponents);
    gridPositions = createGrid(supplyComponents);
    console.log('gridPositions');
    console.log(gridPositions);

    // populate gridData
    iconHash = {}
    positionNodeHash = {}
    gridPositions.forEach(obj => {
        iconHash[`${obj.y}-${obj.x}`] = obj.image_name;
        if (obj.object_type == 'OS_Node') {
          positionNodeHash[`${obj.y}-${obj.x}`] = obj.name
        }
    });
    gridData = {}
    gridData["columns"] = Math.max(...gridPositions.map(obj => obj.x));
    gridData["rows"] = Math.max(...gridPositions.map(obj => obj.y));

    // add angled sections
    iconHash['2-1'] = "right_down.png"
    iconHash[`2-${gridData["columns"]}`] = 'left_down.png'

    gridData["iconHash"] = iconHash
    gridData["positionNodeHash"] = positionNodeHash
    console.log('gridData');
    console.log(gridData);

    return gridData
};

function populateLoopDropdown() {
  const dropdown = document.getElementById('airLoopDropdown');
  const attributes = new Set();
  hvac_data.forEach( loop => attributes.add(loop.loop_name) );

attributes.forEach(attribute => {
    const option = document.createElement('option');
    option.value = option.textContent = attribute;
    dropdown.appendChild(option);
  });
}
populateLoopDropdown();

function populateNodeAttributeDropdown() {
  const dropdown = document.getElementById('nodeAttributeDropdown');
  const attributes = new Set();

  hvac_data.forEach(airLoop => {
    airLoop.components.forEach(component => {
      Object.keys(component).forEach(key => {
        if (key.startsWith('system_node')) {
          attributes.add(key);
        }
      });
    });
  });

  attributes.forEach(attribute => {
    const option = document.createElement('option');
    option.value = option.textContent = attribute;
    dropdown.appendChild(option);
  });
}
populateNodeAttributeDropdown();

function getNodeValues(hvac_data, loopName, nodeName, selectedKey) {
  selectedLoopData = hvac_data.find(hash => hash.loop_name === loopName);
  selectedNode = selectedLoopData.components.find(hash => hash.object_name === nodeName);
  return selectedNode[selectedKey];
}

function createGridWithIcons() {
	const gridContainer = document.getElementById('grid-container');
	const gridDataScript = document.getElementById('gridData');
	const loopName = document.getElementById('airLoopDropdown').value;
	const gridData = populateGridData(hvac_data, loopName);

	const columns = gridData.columns;
	const rows = gridData.rows;
	const iconHash = gridData.iconHash;
	const positionNodeHash = gridData.positionNodeHash;

	// Set grid template columns and rows dynamically
	gridContainer.style.gridTemplateColumns = `repeat(${columns}, 100px)`;
	gridContainer.style.gridTemplateRows = `repeat(${rows}, 100px)`;

	for (let i = 0; i < columns * rows; i++) {
		const row = Math.floor(i / columns) + 1; // 1-indexed row
		const col = (i % columns) + 1; // 1-indexed column
		const position = `${row}-${col}`;
		const gridItem = document.createElement('div');
		gridItem.className = 'grid-item';

		if (iconHash[position]) {
			const img = document.createElement('img');
			let alternateDirectoryTried = false;
			img.onerror = function () {
				console.log("Image not found in measure directory path; trying an alternate path for tests.");
				if (!alternateDirectoryTried) {
					alternateDirectoryTried = true;
					img.src = `../../../resources/images/${iconHash[position]}`;
				} else {
					console.log("Image not found in the alternate path as well.");
					// Handle the case where the image is not found in both paths
				}
			}
			img.src = `../../measures/detailed_hvac_viewer/resources/images/${iconHash[position]}`;
			img.className = 'grid-icon';
			gridItem.appendChild(img);

			// Add hover effect only if the cell has an icon
			gridItem.addEventListener('mouseover', () => {
				if (!activeNodes[position]) {
					gridItem.style.backgroundColor = '#888';
				}
			});
			gridItem.addEventListener('mouseout', () => {
				if (!activeNodes[position]) {
					gridItem.style.backgroundColor = '#ccc';
				}
			});

			// Add click event listener for relevant nodes
			if (positionNodeHash[position]) {
				gridItem.addEventListener('click', () => {
					const nodeName = positionNodeHash[position];
					const attributeName = document.getElementById('nodeAttributeDropdown').value;
					const NodeValues = getNodeValues(hvac_data, loopName, nodeName, attributeName);
					if (NodeValues) {
						if (activeNodes[position]) {
							delete activeNodes[position];
							gridItem.style.backgroundColor = '#ccc';
						} else {
							const color = getRandomColor();
							activeNodes[position] = { nodeName, NodeValues, color };
							gridItem.style.backgroundColor = color;
						}
						plotNodeValues();
					}
				});
			}
		}
		gridContainer.appendChild(gridItem);
	}
}

// Call the function to create the grid with icons
createGridWithIcons();

function selectLoopEvent() {
  var dropdown = document.getElementById('loopDropdown');

  // Add change event listener to the dropdown
  dropdown.addEventListener('change', function() {
      // Get the selected option value
      var selectedOption = dropdown.options[dropdown.selectedIndex].value;
      console.log("Regenerating grid with option value:", selectedOption);

      // Clear the content of the div
      gridContainer = document.getElementById('grid-container');
      gridContainer.innerHTML = "";

      // Call function to regenerate the grid
      createGridWithIcons();
  });
}

// Call function to attach event listener when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', selectLoopEvent);

function plotNodeValues(data) {
    d3.select("#plot").html(""); // Clear any existing plot

    const margin = {top: 20, right: 20, bottom: 30, left: 50};
    const width = 1000 - margin.left - margin.right;
    const height = 300 - margin.top - margin.bottom;

    // Define the start and end dates for one year starting on January 1st
    const startDate = new Date(2023, 0, 1);
    const endDate = new Date(2024, 0, 1);

	// Create a time scale for the x-axis
    const x = d3.scaleTime()
				.domain([startDate, endDate])
				.range([0, width]);

    const yMax = d3.max(Object.values(activeNodes), d => d3.max(d.NodeValues));
    const yMin = d3.min(Object.values(activeNodes), d => d3.min(d.NodeValues));

    const y = d3.scaleLinear()
                .domain([yMin, yMax])
                .range([height, 0]);

    // Define the line function
    const line = d3.line()
        .x((d, i) => x(new Date(2023, 0, 1, i + 1)))
        .y(d => y(d));

    // Create the SVG container
    const svg = d3.select("#plot").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Add the x-axis
    svg.append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x).ticks(d3.timeMonth.every(1)).tickFormat(d3.timeFormat("%b")));


    svg.append("g")
		.call(d3.axisLeft(y));

	Object.values(activeNodes).forEach(node => {
		svg.append("path")
			.data([node.NodeValues])
			.attr("class", "line")
			.attr("d", line)
			.attr("stroke", node.color);
	});
}

function getRandomColor() {
	const letters = '0123456789ABCDEF';
	let color = '#';
	for (let i = 0; i < 6; i++) {
		color += letters[Math.floor(Math.random() * 16)];
	}
	return color;
}
</script>

</body>
</html>
